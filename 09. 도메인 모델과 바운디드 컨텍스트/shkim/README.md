# 도메인 모델과 바운디드 컨텍스트

## 도메인 모델과 경계

이 절에서는 하위 도메인과 바운디드 컨텍스트에 대해 알아본다.  
하나의 도메인 모델로 여러 하위 도메인을 모두 표현하려는 시도는 오히려 모델의 혼란을 초래한다.  
예를 들어, ‘상품’이라는 개념은 카탈로그, 재고, 주문, 배송 도메인마다 의미가 다르다.  
카탈로그에서는 상품 정보 자체를, 재고 관리에서는 실제 존재하는 물건을, 주문에서는 주문 가능한 항목을, 배송에서는 보내는 물건을 의미한다.  
이렇게 같은 단어라도 하위 도메인에 따라 지칭하는 대상이 달라질 수 있다.

따라서 올바른 도메인 모델을 개발하려면 하위 도메인마다 독립적인 모델을 만들어야 한다.  
각 모델은 명확한 경계를 가져야 하며, 서로 섞이면 의미가 약해지고 요구사항 반영이 어려워진다.  
즉, 모델은 특정한 문맥(Context) 안에서만 완전한 의미를 가진다. 같은 ‘상품’이라도 카탈로그 문맥과 재고 문맥에서 의미가 다르다.

DDD에서는 이러한 문맥의 경계를 **바운디드 컨텍스트(Bounded Context)** 라고 부른다. 
바운디드 컨텍스트는 모델이 적용되는 범위를 명확히 구분하여, 도메인 간 혼동을 방지하고 모델의 일관성을 유지하게 한다.

## 바운디드 컨텍스트

바운디드 컨텍스트는 모델의 경계를 결정하며, 하나의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 가진다.  
즉, 용어를 기준으로 도메인을 구분하여 각 컨텍스트 내에서 일관된 의미를 유지하게 만든다.  
카탈로그 컨텍스트와 재고 컨텍스트는 같은 ‘상품’이라는 단어를 사용하더라도 서로 다른 의미를 갖기 때문에, 이를 기준으로 컨텍스트를 분리할 수 있다.

<img width="656" height="331" alt="Image" src="https://github.com/user-attachments/assets/abb87179-37cd-4004-8bc3-0501302e6599" />

바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 구현되며, 각 컨텍스트는 그 안에서 도메인을 완성한다.  
이상적으로는 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋지만, 현실에서는 기업의 조직 구조나 팀 구성에 따라 달라질 수 있다.  
예를 들어 주문 도메인을 담당하는 팀과 결제 도메인을 담당하는 팀이 따로 있다면, 각각의 하위 도메인에 맞는 바운디드 컨텍스트가 존재하게 된다.

작은 규모의 기업에서는 여러 하위 도메인을 하나의 시스템에서 구현하기도 한다.  
예를 들어 소규모 쇼핑몰의 웹 애플리케이션은 회원, 카탈로그, 재고, 구매, 결제 기능을 모두 하나의 시스템 내에서 처리할 수 있다.  
이런 경우 여러 하위 도메인이 하나의 바운디드 컨텍스트로 묶이게 된다. 그러나 이렇게 개발할 때는 각 하위 도메인의 모델이 서로 섞이지 않도록 주의해야 하며, 패키지를 나누는 등 논리적인 경계를 유지해야 한다.

결국 바운디드 컨텍스트는 도메인 모델을 구분하는 경계의 단위로서, 구현되는 하위 도메인에 맞는 모델을 포함한다.  
같은 사용자라도 주문 컨텍스트와 회원 컨텍스트에서의 모델은 다를 수 있다.  
예를 들어 ‘상품(Product)’은 카탈로그 컨텍스트와 재고 컨텍스트 각각에 맞는 모델을 가져야 하며, 회원 컨텍스트의 ‘Member’와 주문 컨텍스트의 ‘Orderer’는 서로 다른 역할을 가진다.  
이렇게 각 바운디드 컨텍스트는 하위 도메인에 적합한 모델을 유지함으로써, 전체 시스템의 일관성과 확장성을 확보할 수 있다.

## 바운디드 컨텍스트 구현

<img width="574" height="445" alt="Image" src="https://github.com/user-attachments/assets/5c929413-8e51-41da-b5c2-c85ea98c83b8" />

바운디드 컨텍스트는 단순히 도메인 모델만 포함하는 것이 아니라, 도메인 기능을 사용자에게 제공하기 위한 여러 영역을 포괄한다. 
바운디드 컨텍스트에는 표현 영역, 응용 서비스, 인프라스트럭처 영역 등이 포함되며, 도메인 모델의 데이터 구조가 바뀌면 DB 스키마 또한 함께 변경되어야 하므로 데이터베이스 역시 바운디드 컨텍스트의 일부로 본다.

표현 영역은 사용자를 위한 HTML 페이지를 생성하거나, 다른 바운디드 컨텍스트에 REST API 형태로 기능을 제공할 수도 있다.  
하지만 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.  
예를 들어 상품 리뷰처럼 복잡한 도메인 로직이 없는 경우에는 단순한 CRUD 방식으로 DAO 중심의 구조를 사용해도 무방하다.  
즉, 데이터 중심의 단순 구조로도 충분히 기능을 유지할 수 있다.

<img width="514" height="454" alt="Image" src="https://github.com/user-attachments/assets/1043c7f4-b8df-487a-a809-22693306995f" />

또한 하나의 바운디드 컨텍스트 안에서도 CQRS 패턴처럼 명령(Command)과 조회(Query)를 분리해 적용할 수도 있다.  
상태를 변경하는 기능은 도메인 모델 기반으로, 조회 기능은 서비스–DAO 형태로 구성하는 식이다. 이렇게 하면 복잡한 로직은 도메인 모델에서 처리하고, 단순 조회는 효율적으로 구현할 수 있다.

각 바운디드 컨텍스트는 서로 다른 기술 스택을 사용할 수도 있다.  
예를 들어 웹 MVC는 스프링 MVC를, 저장소는 JPA/하이버네이트를 사용할 수 있으며, REST API를 제공하는 컨텍스트는 Netty나 마이바티스를 쓸 수도 있다.  
또한 RDBMS 대신 MongoDB 같은 NoSQL을 사용할 수도 있다.

바운디드 컨텍스트가 반드시 사용자 인터페이스(UI)를 포함해야 하는 것도 아니다.  
예를 들어 상품 상세 페이지에서 리뷰를 보여주는 경우, 카탈로그 바운디드 컨텍스트가 상품 정보를 제공하고, 리뷰 바운디드 컨텍스트가 REST API 형태로 리뷰 데이터를 반환해 브라우저가 이를 조합해 화면을 구성할 수 있다.

이 구조를 확장하면, UI 서버를 두고 브라우저의 요청을 UI 서버가 받아 각 바운디드 컨텍스트와 통신하는 방식으로 구현할 수도 있다.  
UI 서버는 파사드(Facade) 역할을 수행하며, 카탈로그와 리뷰 컨텍스트로부터 필요한 데이터를 조합해 브라우저에 응답을 제공한다.  
이렇게 함으로써 각 바운디드 컨텍스트는 독립성을 유지하면서도 사용자에게 통합된 서비스를 제공할 수 있다.

## 바운디드 컨텍스트 간 관계

<img width="642" height="169" alt="Image" src="https://github.com/user-attachments/assets/997ca0dc-7b07-4b9f-8136-7674c788606b" />

두 바운디드 컨텍스트는 서로 연결되어 데이터를 주고받을 수 있으며, 그중 대표적인 관계가 **고객/공급자 관계(Customer/Supplier Relationship)** 다.  
한쪽이 API를 제공하고 다른 쪽이 그 API를 사용하는 형태로, REST API가 주로 사용된다.  
예를 들어 카탈로그 컨텍스트가 추천 컨텍스트의 API를 호출해 추천 상품 정보를 가져오는 구조라면, 카탈로그는 하류(Downstream) 컴포넌트이고 추천 컨텍스트는 상류(Upstream) 컴포넌트가 된다.

상류 컴포넌트는 서비스를 제공하는 공급자 역할을 하며, 하류 컴포넌트는 그 서비스를 사용하는 고객 역할을 한다.  
이런 관계에서는 두 팀 간의 협력이 필수적이다. 상류 팀이 API를 변경하면 하류 팀은 이에 맞춰 코드를 수정해야 하기 때문이다.  
반대로 하류 팀이 새로운 기능을 요청할 경우, 상류 팀은 개발 계획과 일정을 공유하며 조율해야 한다.

<img width="731" height="306" alt="Image" src="https://github.com/user-attachments/assets/cc6b4d86-de8a-44b5-af11-69806a00ab3a" />

또 다른 방식으로는 **공개 호스트 서비스(Open Host Service)** 관계가 있다.  
상류 팀이 여러 하류 팀의 요구를 수용할 수 있는 API를 만들어 공개하고, 이를 통해 서비스의 일관성을 유지하는 방식이다.  
예를 들어 블로그, 카페, 게시판 등의 서비스가 각자 검색 기능을 구현하기보다, 검색 전용 시스템을 구축해 공용 API로 제공하는 경우가 여기에 해당한다. 
이때 검색 시스템은 상류 컴포넌트가 되어, 다른 바운디드 컨텍스트들이 공개된 API를 통해 검색 기능을 사용한다.

두 컨텍스트 간의 의존 관계가 생길 때는 모델 간의 침범을 막기 위해 **안티코럽션 계층(Anticorruption Layer)** 을 둔다.  
이는 외부 시스템의 모델이 내부 도메인 모델에 직접 영향을 미치지 않도록 보호하는 장치다.  
예를 들어 외부 추천 시스템의 데이터를 가져와 내부 도메인 모델로 변환할 때, RecSystemClient가 이 역할을 수행한다. 이렇게 하면 외부 시스템의 변경이 내부 모델에 직접적인 영향을 주지 않는다.

한편 두 바운디드 컨텍스트가 같은 모델을 공유할 수도 있다. 
이를 **공유 커널(Shared Kernel)** 이라고 부르며, 두 팀이 동일한 모델을 함께 사용함으로써 중복을 줄일 수 있다.  
다만 한쪽이 모델을 변경할 때 다른 쪽에도 영향을 주므로, 긴밀한 협력 관계가 유지되어야 한다. 협력이 어려운 경우 오히려 공유 커널이 개발 속도를 늦추고 혼란을 초래할 수도 있다.

마지막으로 **독립 방식(Separate Way)** 은 두 바운디드 컨텍스트가 아예 통합하지 않고 완전히 분리된 상태로 운영되는 관계를 말한다.  
각 컨텍스트는 자체 모델과 로직을 가지고 독립적으로 발전한다. 예를 들어 온라인 쇼핑몰 시스템과 외부 ERP 시스템이 별도로 운영되며, ERP 통합 기능이 없을 경우, 판매 정보는 수동으로 입력해야 한다.  
규모가 커지면 이런 수동 통합에는 한계가 있으므로, 두 컨텍스트를 연결하는 별도의 통합 시스템을 만들어 자동화하는 방향으로 발전하기도 한다.

요약하자면, 바운디드 컨텍스트 간의 관계는 상황과 조직 구조에 따라 다양하게 설계된다.  
고객/공급자 관계, 공개 호스트 서비스, 안티코럽션 계층, 공유 커널, 독립 방식 등은 각기 다른 수준의 결합도와 협력 방식을 가진다. 
이를 적절히 선택함으로써 시스템의 유연성과 유지보수성을 높일 수 있다.








