## 9.1 도메인 모델과 경계

처음 도메인 모델을 만들 때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다. 그런데 1장에서 말한 것처럼 **한 도메인은 다시 여러 하위 도메인으로 구분**되기 때문에 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.

예를 들어, 상품이라는 모델은 카탈로그에 속해 있을 때와 주문에 속해 있을 때 다른 의미를 가진다.

논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다. 시스템을 사용하는 사람을 회원 도메인에서는 회원이라고 부르지만, 주문 도메인에서는 주문자, 배송 도메인에서는 배송자라고 부를 수 있다.

<img width="540" alt="image" src="https://github.com/user-attachments/assets/0b54e14b-372e-4cca-bb14-741da592b490" />


이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.

***모델은 특정한 컨텍스트 하에서 완전한 의미***를 갖는다. 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다. 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트(Bounded Context)라고 부른다.

## 9.2 바운디드 컨텍스트

바운디드 컨텍스트는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다. 바운디드 컨텍스트는 용어를 기준으로 구분한다. **카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다**. 

이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋지만, 현실적으로 그렇지 않을 때가 많다. 바운디드 컨텍스트는 기업의 팀 조직 구조에 다라 결정되기도 한다.  예를 들어 주문 하위 도메인이라도 주문을 처리하는 팀과 복잡한 결제 금액 계산 로직을 구현하는 팀이 따로 있다고 해보자. 이 경우 주문 하위 도메인에 주문 바운디드 컨텍스트와 결제 금액 계산 바운디드 컨텍스트가 존재하게 된다.  용어를 명확하게 구분하지 못해 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다.

<img width="610" alt="image" src="https://github.com/user-attachments/assets/1c5ad769-b9bc-46cf-b056-bef2ec979d11" />


여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할 때 주의할 점은 하위 도메인의 모델이 섞이지 않도록 하는 것이다. 
한 프로젝트에 각 하위 도메인의 모델이 위치하면 아무래도 전체 하위 도메인을 위한 단일 모델을 만들고 싶은 유혹에 빠지기 쉽다. 
이런 유혹에 걸려들면 결과적으로 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해서 하위 도메인별로 기능을 확장하기 어렵게 되고 이는 서비스 경쟁력을 떨어뜨리는 원인이 된다.

<img width="555" alt="image" src="https://github.com/user-attachments/assets/90128d5b-bb32-4a2f-b733-e5dcbd4967d0" />


위 그림처럼 물리적인 바운디드 컨텍스트가 한 개이더라도 내부적으로 패키징을 통해 논리적으로 바운디드 컨텍스트를 만들 수 있다.

바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되기 때문에 바운디드 컨텍스트는 구현하는 하위 도메인에 알맞은 모델을 포함한다. 아래와 같이 말이다. 

카탈로그 컨텍스트와 재고 컨텍스트는 각 컨텍스트에 맞는 Product 모델을 갖는다. 
따라서, 회원의 `Member`는 애그리거트 루트이지만 주문의 `Orderer`는 밸류가 된다. 카탈로그의 `Product`는 상품이 속할 `Category`와 연관관계를 갖지만 재고의 `Product`는 맺지 않는다.

<img width="540" alt="image" src="https://github.com/user-attachments/assets/70091ed3-7212-44bf-9e04-3d47ce71cc22" />


## 9.3 바운디드 컨텍스트 간 통합

바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니다. 바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭쳐 영역을 모두 포함한다. 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 테이블도 바운디드 컨텍스트에 포함된다.

<img width="410" alt="image" src="https://github.com/user-attachments/assets/4f1fc037-8d65-49ef-a92c-b9980b1e38f5" />


온라인 쇼핑 사이트에서 카탈로그 하위 도메인에 개인화 추천 기능을 도입했다고 가정하자. 기존 카탈로그 시스템 개발 팀과 별도로 추천 시스템을 담당하는 팀이 생겨 이 팀이 주도적으로 추천 시스템을 만들기로 했다. **이렇게 되면 카탈로그 하위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.**

<img width="507" alt="image" src="https://github.com/user-attachments/assets/3cc8bee1-341c-4478-9dc4-97573868764d" />


두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 통합이 발생한다. 기능은 아래와 같다.

- 사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다.

이때 카탈로그 컨텍스트와 추천 컨텍스트의 도메인 모델은 서로 다르다. 카탈로그는 제품 중심으로 도메인 모델을 구현하고, 추천은 추천 연산을 위한 모델을 구현한다.

카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기 보단 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야 한다.

<img width="597" alt="image" src="https://github.com/user-attachments/assets/92dca1ff-1751-4b1f-9bc4-b08aa0416b4e" />


외부 연동을 위한 도메인 서비스 구현 클래스는 도메인 모델과 외부 시스템 간의 모델 변환을 처리한다. 즉, `RecSystemClient`을 통해 가져온 응답은 카탈로그 도메인 모델과 일치하지 않을 것이다.

```json
[
	{"itemId": "PROD-1000",  "type": "PRODUCT", "rank": 100},
	{"itemId": "PROD-1001", "type": "PRODUCT", "rank": 54}
]
```

위와 같이 상품의 상세 정보는 포함하지 않고, 상품 번호 대신 아이템 ID라는 용어를 사용할 수도 있다.

때문에 내부적으로 카탈로그 도메인의 Product 모델로 변환하는 작업이 필요하다.

```java
public class RecSystemClient implements ProductRecommendationService {

	private ProductRepository productRepository;

	@Override
	public List<Product> getRecommendationsOf(ProductId id) {
		List<RecommendationItem> items = getRecItems(id.getValue());
		return toProducts(items);
	}
	
	private List<RecommendationItem> getRecItems(String itemId) {
		// 외부 추천 시스템을 위한 클라이언트라고 가정
		return externalRecClient.getRecs(itemId);
	}
	
	private List<Product> toProducts(List<RecommendationItem> items) {
		return items.streamO
						.map(item -> toProductId(item.getItemIdO))
						.map(prodId -> productRepository.findByIcKprodId))
						.toList();
	}
	
	private ProductId toProductId(String itemId) {
		return new ProductId(itemId);
	}
	
}
```

위처럼 REST API를 이용해서 동기 방식으로 처리할 수도 있고, 비동기 방식으로도 처리 가능하다. 메시지 큐가 있다고 가정해보자.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/1b84544e-19af-48c6-bfdd-e9b8a522442a" />


추천 바운디드 컨텍스트는 큐에서 메시지를 읽어 추천을 계산하는데 사용할 것이다. 즉, 두 바운디드 컨텍스트가 사용할 메시지의 데이터 구조를 맞춰야 함을 의미한다. 이는 각 바운디드 컨텍스트를 담당하는 팀이 서로 만나 형식을 협의해야 한다.

*** Note: 마이크로서비스와 바운디드 컨텍스트**

마이크로서비스 특징은 바운디드 컨텍스트와 잘 어울린다. 각 바운디드 컨텍스트는 모델의 경계를 형성하는데 바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트별로 모델이 분리된다. 코드로 생각하면 마이크로서비스마다 프로젝트를 생성하므로 바운디드 컨텍스트마다 프로젝트를 만들게 된다. 이것은 코드 수준에서 모델을 분리하여 두 바운디드 컨텍스트의 모델이 섞이지 않도록 해준다.

별도 프로세스로 개발한 바운디드 컨텍스트는 독립적으로 배포하고 모니터링하며 확장되는데 이 역시 마이크로서비스가 갖는 특징이다.

## 9.4 바운디드 컨텍스트 간 관계

<img width="648" alt="image" src="https://github.com/user-attachments/assets/527538bb-8048-49b1-8204-d85d7320d00c" />


위 그림에서 하류 컴포넌트인 카탈로그 컨텍스트는 상류 컴포넌트인 추천 컨텍스트가 제공하는 데이터와 기능에 의존한다. 즉. 추천 시스템이 제공하는 REST API의 인터페이스가 바뀌면 카탈로그 시스템의 코드도 바뀌게 된다.

상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다. 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스 일관성을 유지할 수 있다. 이런 서비스를 가리켜 **공개 호스트 서비스(Open Host Service)**라고 한다.

상류 컴포넌트의 변경이 하류 컴포넌트들에 영향을 주지 않도록 완충 지대를 만들어줘야 한다.

<img width="672" alt="image" src="https://github.com/user-attachments/assets/7aca1547-6b82-4468-8fc0-9073fd6eaf0f" />


`RecSystemClient`는 외부 시스템의 모델이 자신의 도메인 모델을 침법하지 않도록 만들어주는 안티코럽션 계층(Anticorruption Layer) 역할을 한다. 즉, 자신의 도메인 모델이 깨지는 것을 막아주는 역할을 한다. 

이렇게 개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다. 이 상황을 방지하려면 **전체 비즈니스를 조망**할 수 있는 지도가 필요한데 이를 **컨텍스트 맵**이라고 한다.

<img width="633" alt="image" src="https://github.com/user-attachments/assets/e9d2e85c-9ddf-4177-9618-a637d6a60826" />


위 그림과 같이 바운디드 컨텍스트 영역에 주요 애그리거트를 함께 표시하면 모델에 대한 관계가 더 명확히 드러난다. 
오픈 호스트 서비스(OHS)와 안티코럽션 계층(ACL)만 표시했는데 하위 도메인이나 조직구조를 함께 표시하면 도메인을 포함한 전체 관계를 이해하는데 도움이 된다.
