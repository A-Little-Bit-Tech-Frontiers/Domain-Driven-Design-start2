# 1. 도메인 모델 시작하기

### 도메인?

해결하고자 하는 문제 영역을 뜻한다. 도메인은 하위 도메인으로 다시 나뉠 수 있다.

### 도메인 모델

도메인 자체를 개념적으로 이해하기 위한 모델이다. 이때 하위 도메인을 하나의 개념 모델에서 정의하면 안된다. 모델의 각 구성요소는 특정 도메인으로 한정할 때 의미가 완전해지기 때문이다.

### 일반적인 도메인 모델 패턴

- 사용자 인터페이스 또는 표현 (Presentation)
- 응용 (Application)
- 도메인 (Domain)
- 인프라스트럭처 (Infrastructure)

### 도메인 모델 도출

도메인을 올바르게 구현하기 위해서는 엔티티와 값을 제대로 구분해야 하기 때문에, 차이를 명확하게 이해해야 한다.

- **엔티티 (Entity)**
    - 가장 큰 특징은 **식별자** 를 가진다는 것이다.
    - DB 테이블 엔티티(as JPA Entity)와 도메인 모델 엔티티와의 큰 차이점은 **데이터와 함께 도메인 기능을 제공** 하는 것이다.
    - 또한 도메인 모델 엔티티에서 여러 데이터가 개념적으로 하나일 경우, 값 타입으로 표현할 수 있다.
- **값 (Value)**
    - **개념적으로 완전한 ‘하나’** 를 표현할 때 사용한다.
    - 하위 개념으로 새로 정의할 수 있을 뿐 아니라, 해당 개념을 위한 기능을 추가할 수 있다.
    - 값 타입은 데이터 변경이 필요하면 변경 기능을 제공하기 보다, **안전한 코드를 작성** 하기 위해 기존 데이터를 복사하고 새로운 값과 함께 **객체를 새로 만들어 사용하는 것이 좋다. (불변 객체)**
    - 불변 객체로서 값 타입을 사용하게 되면, 자연스럽게 의미없는 Setter 구현에 의존하지 않게 된다.
- **예시 코드**
    
    **일반 도메인 객체**
    
    ```kotlin
    /**
    * 스킬과 스테이터스는 모두 플레이어의 데이터이지만, 하위 도메인으로서는 서로 다르기 때문에 값 타입으로 분리할 수 있다.
    */
    class Player(
    	var skill_name: String,
    	var skill_cost: Int,
    	var skill_damage: Int,
    	
    	var status_hp: Int,
    	var status_mp: Int,
    	var status_sp: Int
    ) {}
    ```
    
    **도메인에서 값 타입으로 그룹화 후**
    
    ```kotlin
    // 스킬과 스테이터스 라는 개념으로 분리해서 직관적으로 알 수 있게 되었다.
    class Player(
    	var skill: Skill,
    	var status: Status
    ) {}
    
    class Skill(
    	var name: String,
    	var cost: Int,
    	var damage: Int,
    ) {
    	// 값 타입을 위한 전용 기능을 추가할 수 있다.
    	fun use(name: String, player: Player, enemy: Enemy) {
     		enemy.hp -= this.damage;
     		player.sp -= this.cost;
    	}
    }
    
    class Status(
    	var hp: Int,
    	var mp: Int,
    	var sp: Int
    ) {}
    ```
    

### 도메인 용어, 유비쿼터스 언어

도메인 주도 설계에서 언어는 매우 중요하다. 프로덕트를 만드는 **모든 구성원의 공통 언어(유비쿼터스 언어)** 를 만들어 같은 용어를 사용한다. 이렇게 하면 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.