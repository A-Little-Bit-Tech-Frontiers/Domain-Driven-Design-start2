## 11.1 단일 모델의 단점

주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야 한다. Order에서 주문 정보를 가져와야 하고, Producet에서 상품 이름, Member에서 회원 이름과 ID를 가져와야 한다.

<img width="410" alt="image" src="https://github.com/user-attachments/assets/bd285f1e-662f-445e-8587-8103d87d11a8" />

조회 화면 특성상 조회 속도가 빠를수록 좋은데 여러 애그리거트의 데이터가 필요하면 구현 방법을 고민해야 한다. 3장에 나온 식별자를 이용한 애그리거트 참조 방식은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다. 이는 한 번의 SELECT 쿼리로 조회 화면에 필요한 데이터를 읽어올 수 없어 조회 성능에 문제가 생길 수 있다.

객체 지향으로 도메인 모델을 구현할 때 주로 사용하는 ORM 기법은 `Order#cancel()`이나 `Order#changeShippingInfo()` 기능처럼 도메인 상태 변경 기능을 구현하는 데는 적합하지만, 복잡한 조회에는 힘들다.

이런 구현 복잡도를 낮추는 간단한 방법이 있다. 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.

## 11.2 CQRS

시스템이 제공하는 기능을 크게 두 가지로 나누자. 

하나는 상태를 변경하는 기능이다. 새로운 주문을 생성하거나, 배송지 정보를 변경하는 등이 있다. 
또 다른 하나는 상태 정보를 조회하는 기능이다. 주문 상세 내역 보기, 게시글 목록 보기 등이 있다.

도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다. 예를 들어 주문 취소 기능과 배송지 정보 변경 기능은 한 개의 Order 애그리거트를 변경한다. 반면에 **조회 기능에 필요한 데이터를 표시하려면 두 개 이상의 애그리거트가 필요할 때가 많다.**

**상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에** 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.

CQRS는 Command Query Responsibility Segregation의 약자로 아래 그림과 같이 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회 모델을 분리하는 패턴이다.

<img width="697" alt="image" src="https://github.com/user-attachments/assets/d03dab5d-ce5e-4497-9d4a-d109488204e5" />


복잡한 도메인에 어울리는 패턴이다. 예를 들어 온라인 쇼핑에서 다양한 차원에서 주문/판매 통계를 조회해야 한다고 해보자. JPA 기반 단일 도메인 모델을 사용하면 통계 값을 빠르게 조회하기 위해 JPA와 관련된 다양한 성능 관련 기능을 모델에 적용해야 한다. 이런 도메인에 CQRS를 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 기능 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.

<img width="620" alt="image" src="https://github.com/user-attachments/assets/1ce48123-7b40-4812-98b8-849d0110ca3b" />



위 그림에서 조회 모델에는 응용 서비스가 없다. 단순히 데이터를 읽어와 조회하는 기능은 응용 로직이 복잡하지 않기 때문에 컨트롤러에서 바로 DAO를 실행해도 무방하다. 물론 데이터를 표현 영역에 전달하는 과정에서 몇 가지 로직이 필요하다면 응용 서비스 를 두고 로직을 구현하면 된다.

<img width="643" alt="image" src="https://github.com/user-attachments/assets/de5ac354-a2b6-4941-a8b8-bf386b1f58ac" />



명령 모델과 조회 모델의 설계 예시다. 상태 변경을 위한 명령 모델은 객체를 기반으로 한 도메인 모델을 이용해서 구현한다. 반면에 조회 모델은 주문 요약 목록을 제공할 때 필요한 정보를 담고 있는 데이터 타입을 이용한다. 

두 모델 모두 주문과 관련되어 있지만 명령 모델은 상태를 변경하는 도메인 로직을 수행하는 데 초점을 맞춰 설계했고, 조회 모델은 화면에 보여줄 데이터를 조회하는데 초점을 맞춤

명령 모델과 조회 모델이 서로 다른 DB를 사용하는 경우의 동기화는?

<img width="548" alt="image" src="https://github.com/user-attachments/assets/abff937e-d2be-4276-bef4-aef4b4c9ebc9" />


명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다. 

명령 모델에서 데이터가 바뀌자마자 변경 내역을 바로 조회 모델에 반영해야 한다면 **동기 이벤트**와 **글로벌 트랜잭션**을 사용해서 실시간으로 동기화할 수 있다.

서로 다른 저장소의 데이터를 특정 시간 안에만 동기화해도 된다면 비동기로 데이터를 전송하면 된다.  예를 들어 통계 처리 목적으로 조회 전용 저장소를 구축했다고 하자. 통계 데이터는 수초, 수분 또는 1시간 단위로 최근 데이터를 반영해도 문제가 되지 않을 때가 많다.
