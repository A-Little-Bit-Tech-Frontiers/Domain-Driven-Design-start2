# CQRS

## 단일 모델의 단점

이 절에서는 **조회 기능과 도메인 모델 분리의 필요성**에 대해 다룬다.  
주문 내역 조회 기능을 구현하려면 `Order`에서 주문 정보, `Product`에서 상품 이름, `Member`에서 회원 이름과 ID를 가져와야 한다. 즉, 여러 애그리거트의 데이터를 동시에 사용해야 한다.

### 조회 시 발생하는 문제

조회 화면은 빠른 응답 속도가 중요하지만, 여러 애그리거트의 데이터를 한 번에 가져와야 하므로 성능과 구현 복잡도가 문제로 떠오른다.  
JPA와 같은 ORM을 사용하면 즉시 로딩(eager loading)이나 지연 로딩(lazy loading) 방식으로 데이터를 불러올 수 있지만, 여러 번의 SELECT 쿼리가 발생하거나 성능 최적화가 어려워질 수 있다.  
또한 애그리거트 간의 연관이 단순 식별자가 아닌 직접 참조일 경우, 조회 시점에 불필요한 로딩이 일어나거나 복잡한 쿼리가 만들어질 위험이 있다.

결국 시스템의 상태를 변경하는 기능과 조회 기능이 같은 도메인 모델을 공유할 때, ORM이 제공하는 일반적인 객체 모델 방식만으로는 효율적인 조회를 구현하기 어렵다.  
예를 들어 `Order#cancel()`이나 `Order#changeShippingInfo()`처럼 상태 변경을 위한 기능은 도메인 모델 중심의 구조로 구현하기 적합하지만, 주문 상세 조회처럼 여러 애그리거트에서 데이터를 합쳐서 보여주는 기능에는 맞지 않는다.

### 해결 방법: 명령과 조회 모델의 분리 (CQRS)

이러한 복잡도를 줄이는 간단한 방법은 **상태 변경을 위한 모델과 조회를 위한 모델을 분리**하는 것이다.  
즉, 시스템의 **명령(Command)** 과 **조회(Query)** 를 다른 모델로 구현하는 패턴을 사용한다. 이를 **CQRS(Command Query Responsibility Segregation)** 라고 한다.

CQRS를 적용하면 상태 변경(주문 생성, 취소 등)은 도메인 모델을 통해 엄격히 제어하고, 조회는 별도의 단순화된 데이터 모델이나 전용 쿼리로 처리할 수 있다.  
이렇게 하면 조회 성능을 높이는 동시에, 도메인 모델의 복잡도를 줄이고 명확한 역할 분리가 가능해진다.

요약하자면,
- 도메인 모델은 **상태 변경 로직**에 집중하고,
- 조회는 **별도의 모델**이나 전용 쿼리로 처리해야 한다.

이 분리를 통해 시스템은 더 단순해지고, 성능과 유지보수성이 모두 향상된다.

## CQRS

시스템이 제공하는 기능은 크게 두 가지로 나눌 수 있다.

1. **상태를 변경하는 기능** — 예를 들어 주문 생성, 배송지 변경, 회원 비밀번호 변경 등이 이에 해당한다.  
   이런 기능은 현재 저장된 데이터를 수정하거나 새로운 상태를 반영하는 로직으로 구성된다.
2. **상태를 조회하는 기능** — 예를 들어 주문 내역 보기, 게시글 목록 조회, 회원 정보 보기 등이 이에 해당하며,  
   주로 데이터를 읽어와 사용자에게 보여주는 역할을 한다.

### CQRS의 개념

도메인 모델 관점에서 보면 상태 변경 기능은 주로 하나의 애그리거트의 상태를 변경한다.  
예를 들어 주문 취소나 배송지 변경 기능은 `Order` 애그리거트 내에서 이루어진다.  
반면, 조회 기능은 여러 애그리거트의 데이터를 한 번에 가져와야 하는 경우가 많다.  
이 때문에 단일 도메인 모델로 두 종류의 기능을 모두 구현하려 하면 모델이 복잡해지고 비효율적이 된다.

<img width="666" height="525" alt="Image" src="https://github.com/user-attachments/assets/cfe6f53e-8f6a-4ffa-ae71-46ba81737bc2" />

이를 해결하기 위한 방법이 바로 **CQRS**이다.  
CQRS는 ‘Command Query Responsibility Segregation’의 약자로,  
**상태를 변경하는 명령(Command)** 과 **상태를 조회하는 쿼리(Query)** 를 별도의 모델로 분리하는 패턴이다.

<img width="597" height="451" alt="Image" src="https://github.com/user-attachments/assets/079eec87-0cb1-4e28-aec1-1022438dc2c0" />

### CQRS의 구조와 구현

CQRS 패턴은 다음과 같은 구조로 구성된다.

- **명령 모델(Command Model)** : 도메인 로직을 실행하여 데이터를 변경하는 모델.  
  예를 들어 주문 생성, 결제, 배송지 변경 등의 로직이 포함된다.
- **조회 모델(Query Model)** : 단순히 데이터를 읽어와 화면에 표시하는 역할을 담당한다.

두 모델은 같은 데이터베이스를 사용할 수도 있지만, 구현 방식이 서로 다를 수 있다.  
명령 모델은 보통 객체 지향 기반의 JPA 리포지토리를 사용하고,  
조회 모델은 마이바티스(MyBatis)나 SQL 기반 DAO를 사용해 빠른 쿼리 성능을 낸다.

예를 들어 다음과 같이 설계할 수 있다:
- 명령 모델: JPA 리포지토리를 이용해 트랜잭션 단위로 상태 변경 처리.
- 조회 모델: DAO나 MyBatis를 사용하여 필요한 데이터를 빠르게 조회.

### CQRS 적용 시의 데이터 저장소

CQRS에서는 명령 모델과 조회 모델이 **서로 다른 데이터 저장소**를 사용할 수도 있다.  
명령 모델은 데이터의 일관성과 트랜잭션이 중요한 RDBMS를,  
조회 모델은 조회 속도가 중요한 NoSQL을 사용할 수 있다.

이 경우 두 저장소 간의 데이터 동기화는 이벤트를 통해 이루어진다.  
즉, 명령 모델에서 데이터가 변경되면 이벤트가 발생하고, 조회 모델은 이 이벤트를 수신해 변경 내역을 반영한다.  
실시간으로 동기화할 수도 있고, 일정 주기(예: 1분, 1시간)마다 비동기로 동기화할 수도 있다.  
비동기 방식은 조회 전용 저장소의 성능 저하를 방지하고 명령 모델의 응답 속도에도 영향을 주지 않는다.

### 웹 서비스에서의 CQRS 활용

일반적인 웹 서비스는 상태 변경보다 조회 요청이 훨씬 많다.  
예를 들어 온라인 쇼핑몰에서는 주문 요청보다 상품 상세 조회, 카테고리 조회, 검색 요청이 훨씬 빈번하다.  
이처럼 조회 요청이 많은 시스템은 **CQRS의 구조를 자연스럽게 따른다.**

CQRS를 명시적으로 적용하지 않더라도, 조회 성능을 위해 DAO나 캐시를 사용하는 것만으로도 결과적으로 CQRS와 유사한 효과를 얻을 수 있다.  
예를 들어 조회용 캐시나 조회 전용 데이터베이스를 사용하면 명령 모델의 복잡도를 줄이고 성능을 향상시킬 수 있다.

### CQRS의 장점

CQRS의 주요 장점은 다음과 같다:

1. **복잡한 도메인 로직 단순화**  
   명령 모델은 상태 변경 로직에만 집중하고, 조회 모델은 데이터 표시 로직에 집중할 수 있다.  
   이로써 두 모델이 각각의 역할에만 집중하여 설계가 단순해진다.

2. **조회 성능 향상**  
   조회 모델은 캐싱, 인덱스 최적화, 전용 저장소 등 조회에 특화된 기법을 자유롭게 적용할 수 있다.  
   또한 조회 노드를 여러 개 두어 부하를 분산시킬 수도 있다.

3. **확장성과 유지보수성 향상**  
   명령과 조회가 분리되어 있어 각각 독립적으로 확장할 수 있다.  
   예를 들어 조회 트래픽이 많을 경우 조회 모델만 스케일아웃하면 된다.

### CQRS의 단점 및 고려사항

물론 단점도 존재한다.

1. **구현 복잡도 증가**  
   명령 모델과 조회 모델을 따로 관리해야 하므로 코드와 설정이 늘어난다.  
   또한 데이터 동기화를 위한 이벤트 처리나 메시징 시스템이 필요할 수 있다.

2. **추가적인 기술 스택 필요**  
   명령 모델은 JPA, 조회 모델은 MyBatis, 이벤트 처리는 Kafka 등 서로 다른 기술을 사용할 수 있어  
   인프라 구성이 복잡해질 수 있다.

3. **적용 판단의 중요성**  
   CQRS는 복잡한 도메인이나 대규모 트래픽이 발생하는 시스템에서 유리하다.  
   반면, 단순한 시스템에서는 오히려 유지보수 비용이 증가할 수 있다.  
   따라서 서비스의 복잡도와 트래픽 수준에 맞춰 도입을 결정해야 한다.

요약하자면,  
CQRS는 **명령과 조회의 책임을 분리하여 도메인 복잡도를 줄이고 성능을 최적화하는 아키텍처 패턴**이다.  
트래픽이 크고, 조회와 쓰기의 비율이 크게 다른 서비스에서는 특히 효과적이며,  
명령 모델의 순수성을 유지하면서 조회 성능을 극대화할 수 있는 강력한 설계 방식이다.










