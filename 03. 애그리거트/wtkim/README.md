# 3. 애그리거트

### 애그리거트

도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고, 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.

애그리거트 개념을 적용하면, 관련된 객체를 하나의 군집으로 만들고 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있어, 이해하기 쉽고 관리 또한 쉬워진다.

애그리거트 경계를 설정할 때 기본이 되는 것은 **도메인 규칙**과 **요구사항**이다. 도메인 규칙에 따라 **함께 생성되는 구성요소**는 하나의 애그리거트에 속할 가능성이 높다. 여기서 주의할 사항은, 요구사항에 따라 ‘A가 B를 갖는다’ 고 해서 함께 생성되지 않는 구성요소를 애그리거트로 묶을 수 있다는 의미는 아니다.

---

### **애그리거트 루트 객체**

- 애그리거트는 모든 소속 객체가 정상적인 상태를 유지해야 한다. **애그리거트 루트 객체**는 소속 애그리거트의 전체 객체를 관리할 책임을 가진다.
- 애그리거트의 전체 일관성을 지키기 위해, 애그리거트 루트 객체는 애그리거트가 제공할 도메인 기능을 구현한다. **외부 애그리거트는 반드시 이 루트 객체가 제공하는 도메인 기능을 통해서만 접근해야 한다.**
- **논리적인 도메인 모델 기능을 만들기 위한 규칙**
    - 단순 Setter 메서드를 공개 범위로 만들지 않기
    - Value 타입은 **불변 객체**로 구현하기

---

### 트랜잭션 범위

- **한 트랜잭션에서는 하나의 애그리거트만 수정해야 한다.** 이는 애그리거트가 다른 애그리거트를 변경하지 않는다는 것을 의미한다. 애그리거트 내부에서 다른 애그리거트를 변경하게 되면, 독립적인 애그리거트의 책임 범위를 넘어 결합도가 높아지게 된다.
- 기능을 구현할 수록 한 트랜잭션에서 여러 애그리거트를 변경해야 하는 경우가 발생할 수 있다. 이 경우 **응용 계층에서 각 애그리거트의 기능을 호출**하여 수정하도록 구현한다.
- 한 애그리거트에서 수정이 발생하면 **이벤트**를 사용해서 추가 결합없이 다른 애그리거트를 수정하도록 처리할 수도 있다.
    - **ex) Event.raise() 도메인 이벤트를 사용한 비동기 메시지 처리**

---

### 리포지터리

**애그리거트는 하나의 개념**이므로 리포지터리는 애그리거트 전체를 영속화해야 한다. 제공할 때에도 마찬가지로 애그리거트의 모든 구성요소를 포함하는 완전한 애그리거트를 제공해야 한다.

- **애그리거트 참조**
    - ORM 을 사용해서 엔티티 필드로 다른 애그리거트의 엔티티를 참조하고 있는 경우, 탐색의 편의성 때문에 다른 애그리거트에 대한 변경이 쉽게 일어날 수 있어 **애그리거트 관리 규칙에 대한 강제성이 낮다.** 또한, DB 수준에서의 물리적인 참조로 인해 성능 및 확장에 걸림돌이 될 수 있다.
    - 다른 애그리거트를 참조해야 할 경우 **객체 대신 ID 를 사용해서 애그리거트 간 경계를 명확히 한다.** 이렇게 하면 구현 난이도도 낮아지고, 응집도가 높아지는 효과를 얻을 수 있다. 또한 참조 객체가 필요할 때 ID 를 사용해서 탐색할 수 있어 지연 로딩과 같은 효과도 얻을 수 있다.
    - **ID 참조 방식의 단점 : N+1 조회 성능 대응**
        - N 개의 애그리거트 조회 시, 연관 객체가 필요하면 애그리거트 당 N 번의 조회 쿼리를 추가로 실행해야 한다. 이 N+1 문제를 해결하려면 **조인이 포함된 조회 쿼리**를 별도로 만들어 필요 시 사용하면 된다.
        - 한 애그리거트가 여러 타입의 저장소(MongoDB & MySQL 등)를 사용하는 경우 **CQRS** 방식을 사용해 조회 전용 저장소를 만들어 사용할 수 있다.
- **애그리거트 생성 팩토리**
    - 한 애그리거트의 상태를 선제적으로 확인하고 다른 애그리거트를 생성해야 하는 기본 요구사항이 있을 경우, 별도의 도메인 / 팩토리 서비스를 만들 수도 있지만, 애그리거트 내부에서  다른 애그리거트를 생성하는 팩토리 기능을 만들 수 있다.
    - 애그리거트에서 팩토리 기능을 만들면 직접 애그리거트의 상태를 확인하는 로직을 응용 계층에서 만들지 않아도 된다. 이는 **응용 계층에 영향을 주지 않으면서 응집도를 높일 수 있다**는 장점이 있다.
- **애그리거트 영속화**
    - 저장 기능 구현 시, 애그리거트 루트 부터 시작해서 모든 구성요소 객체를 저장해야 한다.
    - 삭제(DB 에서 삭제) 기능 또한 루트 부터 모든 구성요소를 삭제해야 한다.