# 💡 3.1 애그리거트

- 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는 게 중요하다.
- 상위 수준을 정리하지 않고 개별 관계를 파악하려고 하면 구조를 이해하는 데 어려움을 겪게 된다.
- 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워 진다는 것을 의미한다.
- 애그리거트는 상위 수준에서 모델을 바라볼 수 있게 해주는 도구이다.
  - 애그리거트: 관련된 객체를 하나의 군으로 묶어 준다.

![image](https://github.com/user-attachments/assets/f589d83a-2e00-433b-b758-8b538a9eab5d)

- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다. 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.
- 애그리거트는 경계를 갖는데, 경계를 나누는 기준은 도메인 규칙과 요구사항이다.
  - 보통 A가 B를 가진다라고 했을 때, A와 B를 하나의 애그리거트로 볼 수도 있지만, 그렇지 않은 경우도 있으니 주의하자. (상품과 리뷰 예시를 떠올려 보자.)

# 💡 3.2 애그리거트 루트

- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다.

![image](https://github.com/user-attachments/assets/f277cde3-15ba-49c1-a49e-7a76c573069d)

### 3.2.1 도메인 규칙과일관성

- ❗ 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
- 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
  - 예를 들어, 배송이 시작되기 전까지만 배송지 정보를 변경할 수 있다는 도메인 규칙이 있다면, 애그리거트 루트인 Order의 changeShippingInfo() 메서드는 이 규칙에 따라 배송 시작 여부를 확인하고 규칙을 충족할 때만 배송지 정보를 변경해야 한다.
 
- ❗ 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다. 이것은 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.
- 일관성을 지키기 위해 상태 확인 로직을 응용 서비스에 구현할 수도 있다. 하지만 이렇게 되면 동일한 검사 로직을 여러 응용 서비스에서 중복으로 구현할 가능성이 높아져 유지 보수에 도움이 되지 않는다.
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.
  - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
  - 밸류 타입은 불변으로 구현한다.

### 3.2.2 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
  - 예를 들어 Order는 총 주문 금액을 구하기 위해 OrderLine 목록을 사용한다.
- 애그리거트 루트가 구성요소의 상태를 참조하는 것 뿐만 아니라 기능 실행을 위임하기도 한다. (도메인 규칙과 함께)
- 애그리거트 루트를 제외하고는 public접근 제어자를 최대한 피하자! -> 보통 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 protected 범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지할 수 있다.

### 3.2.3 트랜잭션 범위

- 애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하는 것을 피하자! -> 애그리거트 간 결합도가 높아지게 되면 유지보수 비용이 증가한다.
- 만약 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.
  - 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.

# 💡 3.3 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
  - Order와 OrderLine을 물리적으로 각각 별도의 DB테이블에 저장한다고 해서 Order와 OrderLine을 위한 리포지터리를 각각 만들지 않는다.
  - Order가 애그리거트 루트이고, OrderLine은 애그리거트에 속하는 구성요소이므로 Order를 위한 리포지터리만 존재한다.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
  - 애그리거트를 저장할 때 애그리거트 루트와 매핑되는 테이블뿐만 아니라 애그리거트에 속한 모든 구성요소에 매핑된 테이블에 데이터를 저장해야 한다.
- 동일하게 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다. 즉, Order 애그리거트를 조회하면 Order 뿐만 아니라 OrderLine, Orderer 등 모든 구성요소를 포함하고 있어야 한다.

# 💡 3.4 ID를 이용한 애그리거트 참조
- 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.
- 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같다.
- 애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다.
- ❗ 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공하지만, 다음과 같은 문제를 야기할 수 있다.
  - 편한 탐색 오용
  - 성능에 대한 고민
  - 확장 어려움
- [편한 탐색 오용] 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.
  - 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.
  - 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.
- [성능에 대한 고민] JPA를 사용하면 참조한 객체를 지연(lazy)로딩과 즉시(eager)로딩의 두 가지 방식으로 로딩할 수 있는데, 조회기능이냐 수정기능이냐에 따라 로딩전략을 다르게 가져가야 한다.
- [확장 어려움] 하위 도메인마다 서로 다른 DBMS를 사용할 때도 있는데, 이것은 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.
- 이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.

![image](https://github.com/user-attachments/assets/f6d26848-5fa9-491b-b146-bcfc36d51f2e)

- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
  - 이는 애그리거트의 경계를 명확히 하고, 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다.
- 구현 복잡도도 낮아진다. 다른 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 지연 로딩으로 할지 즉시 로딩으로 할지 고민하지 않아도 된다. 참조하는 애그리거트가 필요하면 응용 서비스에서 ID를 이용해서 로딩하면 된다.
- ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지할 수 있다.
- 애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다. 중요한 데이터인 주문 애그리거트는 RDBMS에 저장하고 조회 성능이 중요한 상품 애그리거트는 NoSQL에 저장할 수 있다.

# 💡 3.5 애그리거트 간 집합 연관

- 카테고리와 상품 간의 연관을 생각해보자.
- 카테고리 입장에서 한 카테고리에 한 개 이상의 상품이 속할 수 있으니 카테고리와 상품은 l-N 관계이다. 한 상품이 한 카 테고리에만 속할 수 있다면 상품과 카테고리 관계는 N-1 관계이다.
- 애그리거트 간 l-N 관계는 Set과 같은 컬렉션을 이용해서 표현할 수 있다.
- 그런데 개념적으로 존재하는 애그리거트 간의 1-N 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과는 상관없을 때가 있다.
- 특정 카테고리에 속한 상품 목록을 보여주는 요구사항을 생각해 보면, 하나의 카테고리에 수백만 가지의 상품이 존재할 수 있는데, 이는 메모리 부족 문제를 야기할 수 있다.
- 개념적으로는 애그리거트 간에 1-N 연관이 있더라도 이런 성능 문제 때문에 애그리거트 간의 l-N 연관을 실제 구현에 반영하지 않을 수도 있다.

# 💡 3.6 애그리거트를 팩토리로 사용하기

![image](https://github.com/user-attachments/assets/186e2f5f-677f-4991-b050-18cb27d3829d)

- 이 코드는 Product를 생성 가능한지 판단하는 코드와 Product를 생성하는 코드가 분리되어 있다.
- 중요한 도메인 로직 처리가 응용 서비스에 노출되었고, 코드 응집도도 낮아진 상태이다.
- Store가 Product를 생성할 수 있는지를 판단하고 Product를 생성하는 것은 논리적으로 하나의 도메인 기능인데 이 도메인 기능을 응용 서비스에서 구현하고 있는 것이다.
- 이 도메인 기능을 넣기 위한 별도의 도메인 서비스나 팩토리 클래스를 만들 수도 있지만 이 기능을 Store 애그리거트에 구현할 수도 있다. -> 애그리거트를 팩토리로 사용한다.

![image](https://github.com/user-attachments/assets/29a2596a-34f0-45ed-8545-5ba5b6cc21cb)

- Store 애그리거트의 createProduct()는 Product 애그리거트를 생성하는 팩토리 역할을 한다. 팩토리 역할을 하면서도 중요한 도메인 로직을 구현하고 있다.
- 이제 응용 서비스는 팩토리 기능을 이용해서 Product를 생성하면 된다.

![image](https://github.com/user-attachments/assets/3139da62-5d89-4833-8dd1-3fcf57ba49a3)

- 앞선 코드와 차이점이라면 응용 서비스에서 더 이상Store의 상태를 확인하지 않는다는 것이다.
- Store가 Product를 생성할 수 있는지 확인하는 도메인 로직은 Store 애그리거트에서 구현하고 있다.
- 이제 Product 생성 가능 여부를 확인하는 도메인 로직을 변경해도 도메인 영역의 Store만 변경하면 되고 응용 서비스는 영향을 받지 않는다. 도메인의 응집도도 높아졌다.
- ❗애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해 보자.
  - Product의 경우 제품을 생성한 Store의 식별자를 필요로 한다. 즉 Store의 데이터를 이용해서 Product를 생성한다.
  - 게다가 Product를 생성할 수 있는 조건을 판단할 때 Store의 상태를 이용한다.
  - 따라서 Store에 Product를 생성하는 팩토리 메서드를 추가하면 Product를 생성할 때 필요한 데이터의 일부를 직접 제공하면서 동시에 중요한 도메인 로직을 함께 구현할 수 있게 된다.
