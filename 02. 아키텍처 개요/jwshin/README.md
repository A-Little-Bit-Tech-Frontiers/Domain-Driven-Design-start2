# 💡 2.1 네 개의 영역

- 표현 / 응용 / 도메인 / 인프라스트럭처
- 응용 영역은 사용자에게 제공해야 할 기능을 구현한다. 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
  - 주문 취소를 위해서는 DB에서 주문정보를 가져오고, 가져온 주문 도메인 모델에게 '주문 취소' 기능을 위임해야 합니다.
- 도메인 영역은 도메인 모델을 구현한다.
  - 주문, 주문상품, 배송과 같은 도메인 모델이 이 영역에 위치한다.
- 인프라스트럭처는 구현 기술에 대한 것을 다루는 영역이다.
  - 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.
  - 도메인 영역, 응용 영역, 표현 영역에서는 구현 기술을 사용한 코드를 직접 만들지 않는다.

# 💡 2.3 DIP

- 가격 할인 정책을 구현한다고 했을 때, 다음과 같은 과정을 거친다.
1. 고객 정보를 가져온다. -> RDMBS에서 JPA를 통해 데이터를 가져온다.
2. 룰을 이용해서 할인금액을 구한다. -> Drools로 룰을 적용한다.

- 🤔 DIP는 구현 기술이 변경되었을 때, 다른 영역으로의 영향을 최소화 하기 위함입니다.
- 이럴 경우 고수준 모듈이 저수준 모듈을 의존하게 되어 저수준 모듈에 변경이 발생할 경우 고수준 모듈도 수정해야 한다. (OCP 위반)
- 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈이 의존하게 의존성을 역전시켜야 한다. (DIP)
- DIP를 구현하기 추상화한 인터페이스를 사용한다.
- DIP의 또 다른 장점은 '테스트 용이성' 이다. -> 저수준 모듈(실제 구현 객체)를 만들기 전에 추상화된 인터페이스를 먼저 정의해서 Mocking하면 실제로 구현 하기 전에 테스트를 진행할 수 있다.

### DIP와 아키텍처

- 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고, 응용 영역과 도메인 영역은 고수준 모듈이다.

# 💡 2.4 도메인 영역의 주요 구성요소

![image](https://github.com/user-attachments/assets/c000776c-5c54-44bd-960e-c4dff2d8e30c)

### 엔티티와 벨류

- DB테이블의 엔티티와 도메인 모델의 엔티티는 다르다.
- 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다.
  - 예를 들어, 주문 엔티티는 주문과 관련된 데이터 뿐만 아니라 배송 주소를 변경하는 기능도 제공한다.
- 또, 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입으로 표현할 수 있다. (RDBMS에서 밸류 타입을 표현하기는 쉽지 않다.)

### 애그리거트

- 애그리거트는 관련된 객체를 하나로 묶은 군집이다.
- 주문 애그리거트 -> 주문, 배송지, 주문자, 주문 목록, 총 결제 금액...
- 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있다.
- 루트 엔티티는 애그리거트에 속한 엔티티와 밸류 오브젝트를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
  -> 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화한다.
- 예를 들어, 주문 애그리거트는 주문 루트 애그리거트를 통하지 않고 배송지 정보를 변경하는 방법을 제공하지 않는다. (캡슐화의 이점)

### 리포지토리

- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라고 하면, 리포지토리는 구현을 위한 도메인 모델이다.
- 리포지토리는 '애그리거트 단위'로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
  - 🤔 예를 들어, 주문 애그리거트는 주문 리포지토리를 통해서 주문, 배송지, 주문자, 주문 목록, 총 결제 금액을 모두 조회해야 한다는 의미로 해석됩니다.

 # 💡 2.6 인프라스트럭처 개요

 - 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원한다.
 - 앞서 인프라스트럭처는 시스템의 유연성, 테스트 용이성을 위해 DIP를 하는 것이 좋다고 했지만, 일부는 직접 의존해도 된다.
 - 예를 들어, 도메인 영역에서 JPA관련 코드를 쓴다거나, 응용 영역에서 @Transactional을 쓴다거나 한다는 식으로 말이다.
 - 시스템의 유연성, 테스트의 용이함만큼이나 구현의 편리함도 중요하다.
 
