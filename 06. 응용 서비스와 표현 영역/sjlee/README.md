## 1. 표현 영역과 응용 영역

<img width="626" alt="image" src="https://github.com/user-attachments/assets/a71f5a30-4458-4a54-ac55-e821d6e1918e" />

실제 사용자가 원하는 기능을 제공하는 곳은 응용 영역이다. 즉 사용자와의 상호작용은 표현 영역이 처리하기 때문에, 응용 서비스는 표현 영역에 의존하지 않는다. 
응용 영역은 사용자가 웹 브라우저에서 호출하는지 REST API를 호출하는지, TCP 소켓을 사용하는지 알 필요가 없다. 단지 기능 실행에 필요한 입력 값을 받고 실행 결과만 리턴하면 될 뿐이다.

---

## 2. 응용 서비스의 역할

응용 서비스는 사용자(클라이언트)가 요청한 기능을 실행한다. 응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용한다.  
응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이므로 표현(사용자) 영역 입장에서 보았을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 창구역할을한다.   
새로운 애그리거트를 생성하는 응용 서비스를 예시로 들면 아래와 같다. 

```java
public Result doSomeCreation(CreateSomeReq req) { // 1. 데이터 중복 등 데이터가 유효한지 검사한다.
	 validate(req);

	// 2. 애그리거트를 생성한다.
	SomeAgg newAgg = createSome(req);
	
	// 3. 리포지터리에 애그리거트를 저장한다.
	someAggRepository .save(newAgg);

	// 4. 결과를 리턴한다.
	return createSuccessResult(newAgg);
}
```

응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다. 응용서비스가 도메인 로직을 일부구현하면 중복,로직분산 등 코드품질에 안 좋은 영향을 줄 수 있다.


---


### 2.1 도메인 로직 넣지 않기

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.   
첫 번째 문제는 **코드의 응집성이 떨어진다는 것**이다. 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고 서로 다른 영역에 위치한다는 것은 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 의미한다.    

두 번째 문제는 **여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다는 것**이다. 
예를 들어 비정상적인 계정 정지를 막기 위해 암호를 확인한다고 해보자. 
이 경우 계정 정지 기능을 구현하는 응용 서비스는 암호를 검증하는 코드를 구현해야 한다. 
코드 중복을 막기 위해 응용 서비스 영역에 별도의 보조 클래스를 만들 수 있지만, 애초에 도메인 영역에 암호 확인 기능을 구현했으면 응용 서비스는 그 기능을 사용하기만 하면 된다. 


예를 들어, 암호 데이터를 가진 Member 객체에서 암호 확인 기능을 구현하고 응용 서비스에서는 도메인이 제공하는 기능을 사용하면 되는 것이다.   
**소프트웨어가 가져야 할 중요한 경쟁 요소 중 하나는 변경 용이성**인데, 변경이 어렵다는 것은 그만큼 소프트웨어의 가치가 떨어 진다는 것을 의미한다. **소프트웨어의 가치를 높이려면 도메인 로직을 도메인 영역에 모아서 코드 중복을 줄이고 응집도를 높여야 한다.**


---

## 3. 응용 서비스의 구현
응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에 서 퍼사드와 같은 역할을 한다.

<br>

### 3.1 응용 서비스의 크기
예를 들어, 회원 도메인을 생각해 보자. 응용 서비스는 회원 가입하기, 회원 탈퇴하기, 회원 암호 변경하기, 비밀번호 초기화하기와 같은 기능을 구현하기 위해 도메인 모델을 사용하게 된다. 이 경우 응용 서비스는 보통 다음의 두 가지 방법 중 한 가지 방식으로 구현한다.

1. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
2. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

#### 한 응용 서비스 클래스
한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다.   
하지만, 한 서비스 클래스의 크기(=라인수)가 커진다는 것은 이방식의 단점이다. 크기가 커지면 연관성이 낮은 코드가 한 클래스에 함께 위치할 가능성이 높아지게 되는데, 결과적으로 관련 없는 코드가 뒤섞여 코드를 이해하는 데 방해가 된다.    
게다가 한 클래스에 코드가 모이기 시작하면 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 된다. 이것은 코드를 점점 얽히게 만들어 코드 품질을 낮추는 결과를 초래한다.


#### 기능별로 분리한 응용 서비스 클래스

이 방식을 사용하면 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로유지하는 데 도움이 된다.  또한 각 클래스 별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.    
각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있다. 이 경우 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다. (e.g. MemberServiceHelper.class)


### 3.2 표현 영역에 의존하지 않기

응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안된다는 점이다. 예를 들어 표현 영역에 해당하는 `HttpServletRequest`나 `HttpSession`을 응용 서비스에 파라미터로 전달하면 안 된다.   
응용 서비스에서 **표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기가 어려워진다.** 게다가 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 하는 문제도 발생한다.    
더 심각한 것은 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다는 것이다. 예를 들어 응용 서비스에 파라미터로 `HttpServletRequest`를 전달했는데 응용 서비스에서 `HttpSession`을 생성하고 세션에 인증과 관련된 정보를 담는다고 해보자.     
`HttpSession`이나 쿠키는 표현 영역의 상태에 해당하는데 이 상태를 응용 서비스에서 변경해 버리면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 추적하기 어려워진다. 즉, 표현 영역의 응집도가 깨지는 것이다. 이것은 결과적으로 코드 유지 보수 비용을 증가시키는 원인이 된다.
