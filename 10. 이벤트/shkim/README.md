# 이벤트

## 시스템 간 강결합 문제

이 절에서는 주문 취소 시 환불 기능을 어떻게 처리할지에 대해 다룬다.  
쇼핑몰에서 사용자가 구매를 취소하면 결제 금액을 환불해야 하는데, 이때 환불을 수행하는 주체는 주문 도메인 엔티티일 수도 있고 응용 서비스일 수도 있다.  
첫 번째 예시에서는 도메인 객체 `Order`가 `RefundService`를 파라미터로 받아 직접 환불 기능을 실행한다. 하지만 이 접근 방식은 외부 결제 시스템에 의존하게 되므로 여러 문제가 발생한다.

첫째, **트랜잭션 처리 문제**다. 환불 중 예외가 발생하면 주문 취소 트랜잭션 전체를 롤백해야 할지, 일부만 커밋해야 할지 판단이 어렵다.  
예를 들어 환불 실패 시 주문 상태를 취소로 변경한 채 그대로 둘 수도 있고, 전체를 되돌릴 수도 있다.

둘째, **성능 문제**다. 외부 결제 시스템의 응답 속도에 따라 주문 취소 기능 전체의 처리 시간이 늘어난다.  
외부 서비스의 지연은 곧 주문 취소 지연으로 이어져 시스템 성능에 직접적인 영향을 준다.

이런 이유로 환불 처리를 도메인 객체가 아닌 **응용 서비스 계층**에서 수행하는 방식이 더 적절할 때가 많다. 응용 서비스는 트랜잭션을 제어하며, 도메인 로직과 외부 시스템 호출을 분리할 수 있다.  
예를 들어 `CancelOrderService`는 `Order` 객체의 상태를 변경한 후 `RefundService`를 호출하여 환불을 진행한다. 이 구조는 트랜잭션의 경계를 명확히 하고 도메인 모델의 순수성을 유지한다.

그러나 여전히 문제는 남아 있다. 외부 서비스 호출이 도메인 로직에 섞여 있으면 **결합도가 높아지고 설계가 복잡해진다.**  
예를 들어 주문 도메인에 결제 로직이 들어가면, 결제 기능이 바뀔 때마다 주문 도메인도 수정해야 하는 문제가 생긴다.  
더 나아가 통지(Notification) 기능까지 추가되면 `cancel()` 메서드의 파라미터가 늘어나고, 트랜잭션 관리가 훨씬 복잡해진다.  
어떤 서비스가 먼저 실패했는지에 따라 처리 순서나 복구 로직을 따로 구현해야 하기 때문이다.

이러한 문제의 근본 원인은 **주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트의 강한 결합(coupling)** 에 있다.  
주문 도메인이 결제 도메인에 직접 의존하기 때문에, 결제 시스템의 변화가 주문 도메인에 그대로 영향을 미친다.

이를 해결하기 위한 방법이 바로 **이벤트(Event)** 를 사용하는 것이다.  
이벤트를 사용하면 두 시스템 간의 결합도를 크게 줄이고, 비동기 방식으로 통신함으로써 트랜잭션 복잡성을 줄일 수 있다.  
예를 들어 “주문 취소됨(OrderCanceled)” 이벤트를 발행하면 결제 컨텍스트는 이를 구독하여 환불을 처리할 수 있고, 주문 컨텍스트는 결제 로직을 몰라도 된다.  
이 방식은 결합도를 낮추면서도 시스템 간 연동을 유연하게 유지할 수 있는 강력하고 실용적인 해결책이다.

## 이벤트 개요

여기서 말하는 ‘이벤트’란 **과거에 발생한 어떤 일**을 의미한다. 예를 들어 ‘회원 암호가 변경됨’, ‘주문이 취소됨’ 같은 상태 변화를 나타낼 때 “이벤트가 발생했다”고 표현할 수 있다.

이벤트는 단순히 발생으로 끝나지 않고, 해당 이벤트에 **반응하는 동작**을 수행하는 기능과 함께 동작한다.  
UI에서 클릭 이벤트가 발생하면 핸들러가 실행되는 것처럼, 도메인 모델에서도 상태 변화가 발생했을 때 이벤트를 발생시키고, 이를 처리하는 핸들러를 통해 후속 작업을 수행할 수 있다.

### 이벤트 관련 구성요소

도메인 모델에서 이벤트를 적용하려면 네 가지 구성요소가 필요하다.

1. **이벤트(Event)** – 발생한 사실을 표현하는 객체
2. **이벤트 생성 주체(Event Publisher)** – 이벤트를 발생시키는 도메인 객체
3. **이벤트 디스패처(Event Dispatcher)** – 이벤트를 전달하는 중개자
4. **이벤트 핸들러(Event Handler)** – 이벤트를 받아서 후속 동작을 수행하는 구독자

예를 들어 `주문 취소됨(OrderCanceledEvent)`이 발생하면, 이벤트 핸들러가 이를 감지해 주문자에게 SMS를 보내거나 환불 절차를 진행할 수 있다.  
이벤트 디스패처는 이벤트 생성 주체가 생성한 이벤트를 핸들러로 전달하며, 구현 방식에 따라 동기 또는 비동기로 동작한다.

### 이벤트의 구성

이벤트 객체는 다음과 같은 정보를 포함한다.

- 이벤트의 종류 (클래스명으로 표현)
- 이벤트 발생 시각
- 추가 데이터 (예: 주문번호, 배송지 정보 등)

예를 들어 배송지 변경 시 발생하는 `ShippingInfoChangedEvent`는 주문번호, 변경 시각, 새 배송지 정보를 담을 수 있다.  
이 이벤트는 `Order` 애그리거트 내에서 생성되어, `Events.raise()` 메서드를 통해 디스패처로 전달된다.

```java
public void changeShippingInfo(ShippingInfo newShippingInfo) {
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo);
    Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
}
```

이벤트를 처리하는 핸들러는 해당 이벤트를 받아 필요한 동작을 수행한다.  
예를 들어 변경된 배송지 정보를 외부 물류 서비스에 전달하는 핸들러는 다음과 같이 작성할 수 있다.

```java
@EventListener(ShippingInfoChangedEvent.class)
public void handle(ShippingInfoChangedEvent evt) {
shippingInfoSynchronizer.sync(evt.getOrderNumber(), evt.getNewShippingInfo());
}
```

이벤트에 필요한 데이터가 충분하지 않다면, 핸들러는 DB나 API를 통해 추가 데이터를 조회할 수도 있다.

### 이벤트의 용도

이벤트는 크게 두 가지 용도로 사용된다.

1. **트리거(Trigger)**  
도메인의 상태가 바뀔 때 후속 처리가 필요하면 이벤트를 트리거로 사용한다.  
예를 들어 주문이 취소되면 환불을 수행해야 하므로 OrderCanceledEvent를 트리거로 사용해 환불 로직을 실행할 수 있다.

2. **시스템 간 데이터 동기화**  
서로 다른 바운디드 컨텍스트나 외부 시스템 간의 상태를 맞추기 위해 사용된다.  
예를 들어 배송지가 변경되면, 주문 시스템에서 발생한 ShippingInfoChangedEvent를 외부 배송 시스템이 구독해 데이터를 동기화할 수 있다.


### 이벤트의 장점

이벤트를 활용하면 서로 다른 도메인의 로직이 섞이는 것을 방지할 수 있다.  
예를 들어, 기존에는 Order 객체의 cancel() 메서드에서 환불 로직을 직접 호출했지만, 이벤트를 적용하면 단순히 OrderCanceledEvent를 발생시키고 환불은 별도의 이벤트 핸들러에서 처리하게 된다.

```java
public void cancel() {
    verifyNotYetShipped();
    this.state = OrderState.CANCELED;
    Events.raise(new OrderCanceledEvent(number.getNumber()));
}
```

이렇게 하면 주문 도메인은 결제 도메인에 의존하지 않게 되어, 두 컨텍스트 간 결합도를 크게 줄일 수 있다.  
또한 새로운 기능이 추가되어도 기존 로직을 수정할 필요가 없다.  
예를 들어, 주문 취소 시 환불과 함께 이메일을 보내고 싶다면, 이메일 전송을 처리하는 별도의 핸들러만 추가하면 된다.

<img width="696" height="337" alt="Image" src="https://github.com/user-attachments/assets/851b87cc-e875-4b02-86da-a69d4af3dfe6" />





