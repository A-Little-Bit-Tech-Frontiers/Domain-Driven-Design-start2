## 10.1 시스템 간 강결합 문제

쇼핑몰에서 구매를 취소하면 환불을 처리해야 한다. 이때 환불 기능을 실행하는 **주체**는 **주문 도메인 엔티티**가 될 수 있다. 도메인 객체에서 환불 기능을 실행하려면 아래 코드처럼 환불 도메인 서비스를 주문 도메인에 파라미터로 넘길 수 있다.

```java

public class Order {
	
	// 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음
	public void cancel(RefundService refundService) {
		verifyNotYetShipped();
		this.state = OrderState.CANCELED;
	
		this.refundStatus = State.REFUND_STARTED;
		try {
			refundService.refund(getPaymentId());
			this.refundStatus = State.REFUND_COMPLETED;
		} catch(Exception ex) {
			// ...
		}
	}
...
```

응용 서비스에서 환불 기능을 실행할 수도 있다.

```java
 public class CancelOrderService {
	private RefundService refundService;

	@Transactional
	public void cancel(OrderNo orderNo) {
		Order order = findOrder(orderNo);
		order.cancel();
		
		order.refundStarted();
		try {
			refundService.refund(order.getPaymentIdO); // 외부 서비스 성능에 영향을 받음
			order.refundCompleted();
		} catch(Exception ex) {
			???
		}
...
```

보통 결제 시스템은 외부에 존재하므로 RefundService는 외부에 있는 결제 시스템이 제공하는 환불 서비스를 호출한다.

이때 두 가지 문제가 발생할 수 있다.

**첫 번째 문제**는 외부 서비스가 정상이 아닐 경우 트랜잭션 처리가 애매하다. 환불 기능을 실행하는 과정에서 익셉션이 발생하면 트랜잭션을 롤백해야 할까? 아니면 일단 커밋을 해야 할까?

외부의 환불 서비스를 실행하는 과정에서 익셉션이 발생하면 환불에 실패했으므로 주문 취소 트랜잭션을 롤백하는 것이 맞아보인다. 지만 반드시 트랜잭션을 롤백 해야 하는 것은 아니다. 주문은 취소 상태로 변경하고 환불만 나중에 다시 시도하는 방식으로 처리할 수도 있다.

**두 번째 문제**는 성능에 대한 것이다. 환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간도 길어진다. 환불 처리 기능이 30초가 걸리면 주문 취소 기능은 30초만큼 대기 시간이 증가한다. 즉, **외부 서비스 성능에 직접적인 영향**을 받게 된다.

(개인적으로 생각하는 **세번째 문제** - 다양한 도메인 서비스에서의 **중복된 애그리거트 메서드 호출**)

---

<img width="559" alt="image" src="https://github.com/user-attachments/assets/85722eec-77d6-4aa6-b75c-323c8f39fa39" />


그리고, 도메인 객체에 서비스를 전달하면 추가로 설계상 문제가 나타날 수 있다. 우선,  위처럼 주문 로직과 결제 로직이 섞이는 문제가 있다.

Order는 주문을 표현하는 도메인 객체인데 결제 도메인의 환불 관련 로직이 뒤섞이게 된다. **이것은 환불 기능이 바뀌면 Order도 영향을 받게 된다는 것을 의미**한다. 주문 도메인 객체의 코드를 결제 도메인 때문에 변경할지도 모르는 상황은 좋아 보이지 않는다.

도메인 객체에 서비스를 전달할 시 또 다른 문제는 기능을 추가할 때 발생한다. 만약 주문을 취소한 뒤에 환불뿐만 아니라 취소했다는 내용을 통지해야 한다면 어떻게 될까? 환불 도메인 서비스와 동일하게 파라미터로 통지 서비스를 받도록 구현하면 앞서 언급한 로직이 섞이는 문제가 더 커지고 **트랜잭션 처리가 복잡**해진다. 

결국 이 문제들이 발생하는 이유는 **주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트간의 강결합 때문**이다. 주문이 결제와 강하게 결합되어 있어서 주문 바운디드 컨텍스트가 결제 바운디드 컨텍스트에 영향을 받게 되는 것이다.

이런 강한 결합을 없앨 수 있는 방법이 있다. 바로 이벤트를 사용하는 것이다.


## 10.2 이벤트 개요

이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미한다. ‘암호 변경됨 이벤트’가 발생한 이유는 회원이 암호를 변경했기 때문이고, ‘주문 취소됨 이벤트’가 발생한 이유는 주문을 취소했기 때문이다.  이벤트는 발생하는 것에서 끝나지 않는다. 이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

### 이벤트 구성요소

도메인 모델에 이벤트를 도입하려면 아래와 같이 이벤트, 이벤트 생성 주체, 이벤트 디스패처(퍼블리셔), 이벤트 핸들러(구독자)를 구현해야 한다.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/29003aed-41b9-4984-9219-69ddb4b413a2" />


도메인 모델에서 **이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은** **도메인 객체**다. 이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다. 

이벤트 핸들러는 이벤트 생성 주체가 발생시킨 이벤트에 반응한다. 이벤트 핸들러는 생성 주체가 발생한 이벤트를 전달 받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다. 예를 들어, ‘주문 최소됨 이벤트’를 받는 이벤트 핸들러는 해당 주문의 주문자에게 SMS로 주문 취소 사실을 통지할 수 있다.

이벤트 생성 주체와 핸들러를 연결해주는 것이 이벤트 디스패처다. 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다. 이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다. 이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.

### 이벤트 구성

이벤트는 발생한 이벤트에 대한 정보를 담는다. 

- 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

배송지를 변경할 때 발생하는 이벤트를 생각해보자. 

```java
public class ShippingInfoChangedEvent {
	private String orderNumber;
	private long timestamp;
	private ShippingInfo newShippingInfo;
	// 생성자, getter
}
```

이 이벤트를 발생시키는 주체는 **Order 애그리거트**다. Order 애그리거트의 배송지 변경 기능을 구현한 메서드는 아래 코드처럼 배송지 정보를 변경한 뒤에 이 이벤트를 발생시킬 것이다. 이 코드에서 `Events.raise()`는 디스패처를 통해 이벤트를 전파하는 기능을 제공한다.

```java

public void changeShippingInfo(ShippingInfo newShippingInfo) {
	verifyNotYetShipped();
	setShippingInfo(newShippingInfo);
	Events.raise(new ShippingInfoChangedEvent(rujmber, newShippingInfo));
}
```

### 이벤트 용도

이벤트는 크게 두 가지 용도로 쓰인다. 

첫 번째 용도는 **트리거**다. 도메인의 상태가 바뀔 때 다른 **후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.** 주문에서는 주문 취소 이벤트를 트리거로 사용할 수 있다.

<img width="604" alt="image" src="https://github.com/user-attachments/assets/7832ff41-be48-44af-95b5-01d375319e5c" />


두 번째 용도는 서로 다른 시스템 간의 **데이터 동기화**다. 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다. 주문 도메인은 배송지 변경 이벤트를 발생 시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.

### 이벤트 장점

이벤트를 사용하면 아래와 같이 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.

<img width="404" alt="image" src="https://github.com/user-attachments/assets/0a7b1100-d51c-4cd0-a814-ff216eae0eda" />


구매 취소 로직에 이벤트를 적용함으로써 환불 로직이 없어진 것을 알 수 있다. `canal()` 메서드에서 환불 서비스를 실행하기 위해 사용한 파라미터도 없어졌다. 

이벤트 핸들러를 사용하면 기능 확장도 용이하다. 구매 취소 시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하면 된다. **기능을 확장해도 구매취소 로직은 수정할 필요가 없다.**

<img width="568" alt="image" src="https://github.com/user-attachments/assets/987b52c6-8bb3-495f-ba2e-281b40d291c7" />


## 10.3 이벤트 처리

아래 이미지는 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다. 즉, 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.

<img width="597" alt="image" src="https://github.com/user-attachments/assets/1bde3d01-3b06-479e-80bb-1ba89ef084e6" />


### 이벤트 적용 시, 고려사항

1. 이벤트 소스를 EventEntry에 추가할지 여부
    
    이벤트 발생 주체에 대한 정보를 같이 저장할지 여부다. 예를 들어, ‘Order 발생시킨 이벤트만 조회하기’와 같은 요구사항이 있다면 고려해봐야 한다.
    
2. 이벤트 손실
    
    비동기 기반의 이벤트 처리에서 이벤트 전송을 실패하면 이벤트가 유실된다. 때문에, 트랜잭션에 성공하면 이벤트가 저장소에 보관되도록 보장하는 등의 방안을 찾아야 한다.
    
3. 이벤트 순서 보장
    
    이벤트 발생 순서대로 외부 시스템에 전달해야 할 경우, 이벤트 저장소를 사용하는 것이 좋다. 이벤트 저장소는 저장소에 이벤트를 발생 순서대로 저장하고 그 순서대로 이벤트 목록을 제공하기 때문이다.
    
4. 이벤트 재처리
    
    동일한 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할지 결정해야 한다. 가장 쉬운 방법은 마지막으로 처리한 이벤트의 순번을 기억해 두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 것이다. 어쨌든 멱등하게 처리하는 방법을 생각해야 한다.
